#### 继承
##### 1.子类于父类
```
继承是一种由已有的类创建新类的机制
由继承而得到的类叫做子类
被继承的类叫做父类（超类）
父类可以是java类库中的类，也可以是自己编写的类，即子类只有一个父类

在类的声明中，使用关键字 extends 来声明一个类是另外一个类的子类]
```
```java
例如：
class 子类名 extends 父类名{
    ......
}
例如：
class Students extends People{
    ......
}
把 Students 声明为 People 类的子类（拓展），而 People 是 Students 的父类（超类）
如果一个类的声明中没有使用关键字 extends ，这个类被系统默认为是 Object 的子类，Object 是包 java.iang 中的类，
也就是说，类声明

class A{
    ......
}
与
class A EXTENDS Object{
    ......
}
是等同的
```
##### 2.子类的继承性
###### 1继承的定义：子类的成员中有一部分是子类自己声明定义的，另外一部分是从它的父类继承的。
###### 2子类和父类在同一个包中的继承性
```
若子类和父类在同一个包中，那么子类自然地继承了其父类中不是 private 的成员变量作为自己的成员变量，
也自然地继承了父类中不是 private 的成员方法作为自己的成员方法。
继承的成员变量以及方法的访问权限保持不变。
```
###### 3.子类和父类不在同一个包中的继承性
```
如果子类和父类不在同一个包中，那么子类继承了父类的 protected 、public 成员变量作为子类的成员变量，
并且继承了父类的 protected、public 方法，继承的成员或方法的访问权限保持不变，
但子类不能继承父类的友好变量的友好方法
```
##### 3.类对象的构造过程
```
若子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法。
可以这样理解子类创建的对象：
1.将子类中声明的成员变量作为子类对象的成员变量
2.父类的成员变量也都分配了内存空间，但只将其中一部分（继承的那部分）作为子类对象的成员变量
```
##### 4员变量隐藏和方法重写
```
1成员变量的隐藏
当在子类中定义的成员变量只要和父类中的成员变量同名时（不必类型相同），子类就隐藏了继承的成员变量，
即子类重新声明定义了这个成员变量

2.方法重写
子类可以隐藏已继承的方法，子类通过方法重写来隐藏继承的方法
重写的方法既可以操作继承的成员变量，也可以操作子类声明定义的成员变量
若子类想使用被隐藏的方法，必须使用关键字"super".
方法重写时一定要保证方法的名字、类型、参数个数和类型同父类的某个方法完全相同
子类重写时，不允许级别低于 protected 级别，级别可以是 protected 或public ,但不允许是private 和友好的

3.访问修饰符 protected 的进一步说明
例如：一个类A中的 protected 成员变量和方法可以被它的直接子类和间接子类继承；
若B是A的子类，C是B的子类，D是C的子类，那么累B C D 都继承了A的 protected 成员变量和方法
那么：
1.子类D 的 protected 成员变量和方法如果不是从父类中继承来的，对象访问这些 protected 成员变量和方法时
只要类 Other 和类D 在同一个包中就可以了
2.如果子类D 的对象的 protected 成员变量或方法或 protected 方法是从父类中继承的，那么就要一直追溯到
该 protected 成员变量或方法的“祖先”类。即类A .
如果类Other 和类A 在同一个包中，Object对象能访问继承的 protected 变量和 protected 方法。
```

##### 5.关键字 super
```
关键字 super 有两种方法：
一、子类使用 super 调用父类的构造方法，
二、子类使用 super 调用被子类隐藏的成员变量和方法

super关键字表示父类（超类）
构造方法的第一行语句必须调用super()
没有调用super()时编译器会自动生成super()语句
如果父类没有默认构造方法，子类就必须显示调用super()


```
##### 6.final 类与final 方法
```
final 类不能继承，即不能有子类
若一个方法被修饰为final 方法，则这个方法不能被重写，
即不允许子类重写隐藏继承的 final 方法，final 方法的行为不允许子类篡改
```
##### 7.对象的向上转型对象
```
对象的向上转型对象的实体是子类负责穿件的，但向上转型对象会失去原对象的一些属性和功能。
向上转型对象具有如下特点：
1.向上转型对象不能操作子类声明定义的成员变量（失去了这部分属性），不能使用子类声明定义的方法（失去了一些功能）
2.向上转型对象可以代替子类对象去调用子类重写的实例方法，如果子类重写的方法是实例方法，
那么向上转型对象调用重写的方法时，就是通知对应子类对象去调用这些方法，因此，若子类重写了父类的某个实例方法后，
子类对象的向上转型对象调用这个方法时，一定是调用了这个重写方法。
3.向上转型对象可以调用子类继承的成员变量和隐藏的成员变量
```

##### 8.继承与多态
```
与继承有关的多态性是指父类的某个实例方法被其子类重写时，可以各自产生自己的功能行为
指同一个操作被不同类型对象调用时可能产生不同的行为
```
##### 9.抽象类
```
用关键字 abstract 修饰的类称为抽象类（abstract 类）
abstract class A{
    ......
}

抽象类特点：
1.抽象类中有抽象方法，也可以有非抽象类方法，对于抽象方法，只允许声明，不允许实现，
而且不允许使用 final 和 abstract 同时修饰一个方法
```
```java
abstract class A {
    abstract int min(int x, int y);
    int max（int x,int y）{
        return x>y?x:y；
    }
}
```
```
2.抽象类不能用 new 运算创建对象
若一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法，给出方法体
即在子类中将抽象方法重新声明，但必须去掉 abstract 修饰，
同时保证声明的方法名字、返回类型、参数个数和类型与父类的抽象方法完全相同
这就是为什么不允许使用 final 和 abstract同时修饰一个方法的原因

3.做向上转型对象
尽管抽象类不能创建对象，但它的非抽象子类必须重写其中的全部抽象方法，
这样一来，就可以让抽象类声明的对象成为其子类对象的向上转型对象，并调用子类重写的方法

```


```
继承 In
继承是面向对象编程的代码复用方式

Student包含Person已有的字段和方法
Student可以从Person继承
继承使用关键字extends
Student获得了Person的所有功能
Student只需要编写新增的功能

Person：超类(super)，父类，基类
Student:子类（subclass），扩展类

Java使用extends继承

被继承类：超类，父类，基类 继承类：子类，派生类

Java只允许继承一个类
一个类有且仅有一个父类（Object除外）

Object是所有类的根类

Person类定义的private字段无法被子类访问
protected修饰的字段和方法可以被子类访问
protected把字段和方法的访问权限控制在继承树内部

向上转型与向下转型 Upcasting Downcasting
可以对实例变量进行向上转型 Upcasting
向上转型把一个子类型安全的变为更加抽象的类型
子类类型可以安全地向上转型为父类类型

可以对实例变量进行向下转型 downcasting
向下转型把抽象的类型变成一个具体的子类型
父类类型可以强制向下转型为子类类型（可能报错ClassCastException）

可以用instanceof判断对象的类型
向下转型前可以用instanceo判断

Student不宜从Book继承
Student可以持有一个Book实例

继承和组合
继承是is关系
组合是has关系
子类和父类的关系是is，has关系不能用继承


```
