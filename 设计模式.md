#### 1.	设计模式
```
套路 ==设计的模式
方法套路

设计模式：如前面的工厂模式

```
#### 2.	什么是模式
```
不是高大上的东西
设计模式：是解决软件设计常见问题的可复用方案----《javascript 设计模式》

设计模式不只是工厂模式包括以下：
1.单例模式
2.适配器模式
3.装配器模式
4.观察者模式
5.MVC模式
6.MVVM模式
.....

模式是解决常见问题的可复用的解决方法。对于模式来说，其有以下三大特征：

已验证的解决方案
容易被复用
富有表达力
```
![]()
#### 3.	反模式
```
反模式是一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生----《javascript 设计模式》

反模式有以下几种：
1.定义大量污染全局命令空间的变量
2.修改Object 类的原型
3.使用 document.write 创建页面
4.硬编码，写死功能等
.....

1.向setTimeout传递字符串,会导致内部触发 eval() 的使用。eval() 方法会造成性能问题和可能会引起安全性的问题。
2.修改Object类的原型，即行为相当于，用其他非标准的方法将内置的标准的类型系统搞乱。
3.定义大量全局变量，会导致出现污染全局命名空间的情况。
4.使用 document.write 来创建接口，是会导致重写我们的页面，而不是增量增加。

```
#### 4.	单例模式
```
一个网站只有一个登录框
一个教室只有一个黑板
一个时期只有一个皇帝
以上的都是单例模式的实例

单例模式：Singleton Pattern
确保一个类只有一个实例共享使用
```
![]()
```
众多设计模式中，单例模式比较常见的一种，面试和工作中也会经常接触到。
设计模式经典 GoF 定义的单例模式需要满足以下两个条件：
保证一个类只创建一个实例
提供对该实例的全局访问点

如果在我们应用场景中需要有类似的实体（有且只需要有一个实例，且可全局访问），那么我们就可以使用单例模式将其实现为一个单例对象。

因此
 A: 对于一个网站而言，许多逻辑都需要有用户登录后才能执行，对于未登录的用户都会弹出登录框提醒用户登录。而登录框非常适合实现为一个单例
 B: 网站的计时器，是记录网站的时间相关情况。为了使整个应用有一个统一的时间情况，通常都会只创建一个计数器来统一记录时间情况
 C: 应用程序中配置对象，可全局访问。同理，为了统一整个应用的配置信息入口，通常一份配置，只会有一个实例对象。
```

#### 5.	适配器模式(Adapter Pattern)

![]()
```
不影响现有实现方式，兼容调用旧接口的代码

适配器模式的使用场景
事实上，适配器模式可以说是一种“亡羊补牢”的模式适配器模式，其并不是我们设计之初想要使用到的。

因为如果我们系统和应用原本的接口能够正常工作的话，相信我们并不会使用上适配器模式。然而在业务中，我们经常会发现，对于过去能够好好工作的接口，或许在未来的某一天却发现已经不能适用于新的系统了。此时如果对系统进行重构耗费的精力和时间太大了。
这时候我们就可以考虑使用适配器模式把旧接口包装成一个新的接口，使它继续保持生命力。
```
![]()
```
我们经常会使用到适配器模式来兼容支持。适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来
可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。
```
##### 适配器模式实例
```
/**
 * 增加数据适配函数 arrToObjAdapter
 * 来兼容我们新功能接口 getUserDetail
 */

// 新功能接口，这个接口在新系统中会广泛使用到
function getUserDetail(user) {
  console.log('当前用户：' + user.name);
  console.log('性别' + user.sex);
  console.log('职业' + user.job);
  console.log('出生日期' + user.date);
}

/**
 * TODO: 实现一个数据适配器 arrToObjAdapter
 * @param arr [Array]
 * @return [Object]
 */
function arrToObjAdapter (arr) {
  return {
    name: arr[0],
    sex: arr[1],
    job: arr[2],
    date: arr[3]
  };
}

// 旧的数据格式如下
var oldData = [
  'andy', // 名称
  'man', // 性别
  'engineer', // 职业
  '1992-10-10' // 出生日期
]; 

```
#### 6.	装饰器模式(Decorator Pattern)
```
在不修改类原来的接口下，动态地为对象添加功能

```
![]()
![]()

#### 7.	 [资料] ES7 decorator

##### ES7 的 Decorator
```
在许多面向对象的语言中都有装饰器（Decorator），用来增加类的功能和职责。

令人喜悦的是，在未来的 JavaScript 中也引入了这个概念，目前 babel 对这个概念也有很好的支持。如果你是一个喜欢尝试
新技术的开发者，可以借助 babel 来大胆使用它。下面让我们来了解一下更多内容。
```
##### 如何使用
Decorator 在目前还只是一个提议。如果你现在就想要体验使用的话，可以通过下面两种方法：

###### 通过使用 Babel 来转换使用
```
首先全局安装babel组件模块
npm install babel -g
命令行开启 Decorator
babel --optional es7.decorators test.js > test.es5.js
```
###### 通过 在线的 REPL 提前体验
Babel 的官方网站提供一个在线转码器，其支持 Decorator 的在线转码。

##### JavaScript 的 Decorator
装饰器（Decorator） 在现代编程语言中是相当普遍的。事实上，JavaScript 装饰器的语法与 Python 装饰器的语法非常相似。
有以下两种用法：

###### 装饰类
装饰类的方法
装饰类
@superManPower
class Man {
  // some code
}

// 装饰器函数
function superManPower(target) {
  target.super = true;
}

// 等同于
class Man {}
// 装饰器函数 superFunc
function superManPower(target) {
  this.super = true;
}
Man = superManPower(Man) || Man;
上面是简单的一个 装饰器（Decorator） 的例子，其中

@superManPower 则为使用装饰器 superManPower
装饰器 superManPower 修改了类 Man 的行为，给其加上静态属性 super
此时装饰器函数是一个对类进行处理的函数。其第一个参数为需要被装饰的目标类，如下：
// 装饰器函数
function superManPower(target) {
  // target 即为被装饰的目标
  target.super = true;
}
###### 装饰类的方法
装饰器除了可以装饰我们的类之外，还可以修饰类的属性方法。如下所示：

function superInitPower(attack, defense) {
  return function(target, key, descriptor) {
    // 保存方法
    const method = descriptor.value;
    // 修改方法
    descriptor.value = (...args)=>{
      // 增加攻击力和防御力
      args[0] += 100;
      args[1] += 100;
      // 调用原本的方法
      return method.apply(target, args);
    }
  return descriptor;
  }
}
class Man {
  @superInitPower
  init(attack, defense) {
    this.attack = attack; // 初始攻击力
    this.defense = defense; // 初始攻击力
  }
}

此时，装饰器函数可以接受三个参数，和我们的 Object.defineProperty() 的参数基本保持一致，分别表示如下：

第一个参数 target 表示修饰的目标对象 即类的实例
这不同于之前装饰类，之前装饰类 target 表示的是类本身

第二个参数 key 表示需要装饰的属性名
第三个参数 descriptor 是该属性的描述对象
// descriptor 对象的值
{
  value: specifiedFunction, // 指定的方法
  enumerable: false, // 是否可遍历迭代
  configurable: true, 
  writable: true
};
###### 多层装饰器
我们可以同时使用多个装饰器，如下所示：

@healthy
class Person {
  @runFase
  @eatHuge
  init() { 
  }
}
例如上面的，我们使用了多个装饰器，增加类和类的方法的职责。

##### 更多参数
上面我们看到装饰器参数都是固定的，对于一些场景可能会不够用。此时我们通过包装一层函数的方式来增加参数，
如下所示：

// 装饰器函数 - 增加参数
function superFunc(num, canUse) {
  return function(target) {
    target.canUse = canUse;
    target.num = num;
  }
}

// 因此下面我们就可以这样调用
@superFunc(1, true)
class Base1() {}
Base1.canUse; // true
Base1.num; // 1

@superFunc(2, false)
class Base2() {}
Base2.canUse; // false
Base2.num; // 2
上面中，我们看到装饰器 superFunc 是可以接受参数，通过各种参数来增强装饰器的能力。

注: 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器本质就是编译时执行的函数。

###### 不能装饰普通函数
事实上 装饰器（Decorator） 只使用与装饰类和类的方法，不能使用于普通函数。这是因为变量提升会产生系列的问题。
这里大家可以查看更多阅读来了解相关的问题详情。

###### 使用场景
我们常常使用 装饰器（Decorator） 来实现 AOP(面向切面编程)。例如前面我们习题讲到的日志，也是非常经典的应用：[日志系统]。(http://taobaofed.org/blog/2015/11/16/es7-decorator/#4%E3%80%81%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0%EF%BC%9ALogger)

###### 更多阅读
想要了解更多知识，大家可以阅读以下的资料文献。

javascript-decorators ：https://github.com/wycats/javascript-decorators
Exploring EcmaScript Decorators
ECMAScript Proposal for JavaScript Decorators(and protocols) ：https://ponyfoo.com/articles/javascript-decorators-proposal
ECMAScript 6 入门 - 阮一峰 ：http://es6.ruanyifeng.com/#docs/decorator

#### 8.	观察者模式
![]()

```
document.body.onclick = function() {
  alert('我是一个观察者，你一点击，我就知道了')；
}
document.body.addEventListener('click,function'() {
  alert('我也是一个观察者，你一点击，我就知道了')；
});

什么是自定义事件
事实上不难理解，在我们 js 中我们有许多事件，如鼠标点击时的 click，键盘的 keyup 等事件，这些都是系统提供给我们的
可以触发使用的事件。但当我们的程序变得越来越复杂的时候，我们发现只靠系统提供的事件监听似乎已经不能满足我们的需求
了。我们就需要我们自己去定义事件。自定义事件 Event 对象 在我们组件开发过程中经常会使用到。
```
![]()
#### 9.	MVC 模式
```
应用复杂性的提高，程序变得臃肿，难以分工开发
通过关注点分离改进程序组织

应用程序：界面、逻辑、数据
```
![]()
![]()

  
#### 10.	MVC 模式实践
```





```
#### 11.	MVVM 模式
```





```
#### 12.	MVVM 模式实践
```





```
#### 13.	 [资料] 双向绑定实现原理
```





```
#### 14.	jQuery 的设计模式
```





```
#### 15.	设计模式结语
```





```
