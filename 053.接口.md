#### 接口

##### 接口声明与使用
```
格式如下：interface 接口的名字
接口 interface
使用 interface 声明一个接口，接口只有抽象方法
```
##### 接口体
接口体包含敞亮定义和方法定义两部分;
接口体中只进行方法声明，不允许提供方法的实现，so 方法的定义没有方法体
例如：
```java
inteerface Printable{
    final int MAX=100;
    void add();
    float sum(float x,floart y);
}
```
##### 接口的使用
```
关键字 implements
实现 interface 使用implements
一个class可以实现多个interface，声明自己实现一个或多个接口，多个接口用逗号隔开接口名
例如：
class A implemenps Printable,Addable
释义：类A使用接口 Printable 和接口 Addable 而

接口中的方法默认 public 和 adstract ,接口在声明时可省略关键字 public 和 adstract；
但在类实现接口方法时，一定要 public 来修饰

若接口的方法返回类型不是 viod 类型，那么在类中实现接口方法时，方法体至少有一个 return 语句；
若接口的方法返回类型是 viod 类型，类体除了“{”和“}”外也可以没有任何语句；
类实现接口方法以及接口中的常量可以被类的对象使用
一个 java 源文件就是由类和接口组成的

关键字 implements前面加上 public ，称这接口为是一个 public 接口；
 public 接口可以被任何类使用，接口不加 public 修饰，称为友好接口类，可以被同一包中的类使用。

接口：

不能定义实例字段
不能定义普通方法
可以定义 default 方法
接口也可以继承，关键字 extends ;
一个接口可以 extends 另一个接口的子接口，相当于扩展接口方法
由于接口中的方法和常量都是 public ，子接口将继承父接口中的全部方法和常量。

接口层次代表抽象程度

接口也是数据类型，适用于向上转型和向下转型
```
##### 接口与多态

多态：即不同对象调用同一操作可能具有不同的行为叫多态


##### 接口回调
```
接口回调是指：可以把使用某一接口的类创建的对象的引用，赋给该接口声明的接口变量中，
那么该接口变量就可以调用被类实现的接口中的方法，当接口变量调用被类实现的接口中的方法时，
就是通知相应的对象调用接口的方法，这一过程称为对象功能的接口回调。

接口回调是多态的另一种体现

不同的类在使用同一接口时，可能具有不同的功能体现
```
##### 接口作为参数
当一个方法的参数是一个接口类型时，若一个类实现了该接口，那么就可以把该类的实例的引用传值给该参数，参数可以回调类的实现的接口的方法。

##### 面向接口
开-闭原理

##### 抽象类于接口的比较
```
1.抽象类和接口都可以有抽象方法
2.接口中只可以有常量；不能有变量；而抽象类中既可以有常量也可以有变量。
3.抽象类中可以非抽象方法，接口不可以。

子类除了需要实现父类的抽象方法，还需要从父类继承一些变量或继承一些重要的非抽象方法，就可以考虑抽象类
若不需要继承，只是需要若干个类给出某些重要的抽象方法的实现细节，就可以考虑使用接口。
```
##### 内部类
```
类的一种成员：内部类
java 支持在一个类中声明另一个类，这样的类称为内部类，而包含内部类的类成为内部类的外嵌类
内部类的类体中不可声明类变量和类方法。外嵌类可以把内部类声明对象作为外嵌类的成员
```
##### 匿名类
###### 与类有关的匿名类
```
类创建对象时，除了构造方法还有类体，此类体被认为是该类的一个子类去掉类声明后的类体，即匿名类。
匿名类可以继承类的方法，也可以重写类的方法
匿名类不可以声明 static 成员变量和 static 方法
匿名类对象的引用必须传递给匹配的参数
匿名类的主要用途就是向方法的参数传值
```
###### 与接口有关的匿名类
```
假设 computable 是一个接口，那么 java 允许直接用接口名和一个类体创建一个匿名对象，
此类体被认为是实现了 computable 接口的类去掉类声明后的类体，即匿名类
```
##### 异常类
```
1.try-catch 语句
当程序运行出现异常时，java 运行环境就用异常类 Exception 的相应子类创建一个异常对象，并等待处理。
读取一个不存在的文件时，运行环境就用异常类 IOExption 创建一个对象

java 使用 try-catch 语句来处理异常，将可能出现的异常操作放在 try-catch 语句的 try 部分，
当 try 部分中的某个语句发生异常后，try 部分将立刻结束执行；
而转向执行相应的catch部分，所以程序可以将发生异常后的处理放在 catch 部分。
try-catch 语句可以由几个 catch 组成，分别处理相应的异常


各catch 参数中的异常类都是 Exception 的某个子类，表明 try 部分可能发生的异常。
这些子类之间不能有父子关系，否则保留一个含有父类参数的 catch 即可。

2.自定义异常类
一个方法在声明时可以使用关键字 throws 声明抛出所要产生的若干个异常，并在该方法的方法体中具体给出产生异常操作，
即用相应的异常类创建对象，这将导致该方法结束执行并抛出所创建的异常对象。

程序必须在 try-catch 语句中调用抛出异常的方法。
```
##### 泛型类：
```
1、泛型类声明
可以使用 “class 名称<泛型列表>” 声明一个类。为了与普通类有所区别，这样声明的类称为泛型类
如： class A <E>
释义：A 是泛型类的名称，E 是其中的泛型。
    E 可以是任何对象或接口，但不能是基本类型数据，
    不用 E 表示泛型也可以，使用一个合理的标识符都可以。但要与我们熟悉的类型名称有所区别

泛型类声明时，“泛型列表”给出的泛型可以作为类的成员变量的类型、方法的类型以及局部变量的类型。
泛型类的类体与普通类的类体完全类似，由成员变量和方法构成

2、使用泛型类声明对象
使用泛型类声明对象时，必须指定类中使用的泛型的具体实际类型
如：
Chorus<Student,Button>model
model=new Chorus<Student,Button>();

3.泛型接口
可以使用 “interface 名称<泛型列表>”声明一个接口，称为泛型接口
例如：interface Comouter<E>
释义：Computer 是泛型接口名称，E 是其中的泛型，泛型类可以使用泛型接口


优点：在使用泛型类建立数据结构时，不必进行强制类型转换，即不要求进行运行时类型的检查，
运行时类型检查提前到编译时执行，使代码更安全。
```



